<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pong Game - Music & Fullscreen</title>
    <style>
        /* --- CSS (Minor adjustments possible for new controls) --- */
        * { margin: 0; padding: 0; box-sizing: border-box; }
        :root { /* ... Color variables ... */
            --bg-color: #282c34; --game-bg: #1e1e1e; --primary-color: #fff;
            --accent-color: #ff5733; --paddle-color: #61dafb; --opponent-color: #f0db4f;
            --button-bg: #333; --star-color: rgba(255, 255, 255, 0.6);
            --win-color1: #ffc700; --win-color2: #ff5733; --win-color3: #61dafb; --win-color4: #f0db4f;
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background-color: var(--bg-color);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            min-height: 100vh; color: var(--primary-color);
            padding: 10px 0;
        }
        #game-container { position: relative; display: flex; flex-direction: column; align-items: center; width: 95%; max-width: 700px; }
        #game {
            position: relative; width: 100%; height: 450px; background-color: var(--game-bg);
            border: 2px solid var(--primary-color); overflow: hidden; cursor: none;
            transition: background-color 0.3s ease;
            /* Ensure game area scales nicely in fullscreen */
            margin-bottom: 15px; /* Add margin below game if controls are always visible */
        }
        /* Style for fullscreen state if needed */
        body:fullscreen #game { /* Example: Make game slightly larger in fullscreen */
           /* width: 90vw;
              height: 70vh; */
              /* Adjust as desired */
        }
        .player { position: absolute; width: 15px; height: 100px; transition: background-color 0.3s ease; }
        #player1 { left: 10px; background-color: var(--paddle-color); }
        #player2 { right: 10px; background-color: var(--opponent-color); }
        #ball { position: absolute; width: 15px; height: 15px; background-color: var(--accent-color); border-radius: 50%; transition: background-color 0.3s ease; }
        #score { position: absolute; top: 10px; left: 50%; transform: translateX(-50%); font-size: 30px; z-index: 10; }
        #modeSelection label, #options label { padding: 5px; margin-right: 5px; cursor: pointer; user-select: none; }
        #modeSelection input[type="radio"] { margin-right: 3px; cursor: pointer; }
        #controls {
            text-align: center; /* margin-top: 15px; Removed margin-top as game has margin-bottom */
            padding: 10px; background-color: rgba(0, 0, 0, 0.3);
            border-radius: 8px; width: 100%;
        }
        #options { margin: 8px 0; display: flex; flex-wrap: wrap; justify-content: center; align-items: center; gap: 10px 15px; }
        #options > div { display: inline-flex; align-items: center; }
        /* Button/Input styles (Unchanged) */
        button, select, label, input[type="number"], input[type="checkbox"], input[type="color"] { padding: 8px 10px; font-size: 14px; background-color: var(--button-bg); border: 1px solid var(--primary-color); border-radius: 5px; color: white; cursor: pointer; margin: 2px; vertical-align: middle; transition: background-color 0.2s ease; }
        button:disabled { opacity: 0.5; cursor: not-allowed; }
        input[type="color"] { padding: 2px; height: 35px; width: 50px; background-color: transparent; border: 1px solid var(--primary-color); }
        input[type="color"]::-webkit-color-swatch-wrapper { padding: 0; }
        input[type="color"]::-webkit-color-swatch { border: none; border-radius: 3px; }
        input[type="color"]::-moz-color-swatch { border: none; border-radius: 3px; }
        input[type="number"] { width: 65px; text-align: center; }
        input[type=number]::-webkit-inner-spin-button, input[type=number]::-webkit-outer-spin-button { -webkit-appearance: none; margin: 0; }
        input[type=number] { -moz-appearance: textfield; }
        button:not(:disabled):hover, select:hover, input[type="number"]:hover, input[type="color"]:hover { background-color: #555; }
        button:focus, select:focus, input[type="number"]:focus, input[type="color"]:focus { outline: 2px solid var(--accent-color); outline-offset: 2px; }
        input[type="checkbox"], input[type="radio"] { margin-right: 5px; cursor: pointer; vertical-align: middle; width: auto; padding: 0; }
        #instructions { margin-top: 10px; font-size: 13px; color: #ccc; min-height: 45px; line-height: 1.4; }
        /* Particle/Win styles (Unchanged) */
        .particle { position: absolute; width: 3px; height: 3px; border-radius: 50%; background-color: var(--star-color); animation: particleAnimation 5s linear infinite; pointer-events: none; z-index: -1; }
        @keyframes particleAnimation { 0% { transform: translate(0, 0); opacity: 0.8; } 100% { transform: translate(calc(var(--particle-vx) * 500px), calc(var(--particle-vy) * 500px)); opacity: 0; } }
        .win-particle { position: absolute; width: 6px; height: 10px; border-radius: 2px; pointer-events: none; z-index: 20; opacity: 1; }
        @keyframes win-explode { 0% { transform: translate(0, 0) rotate(0deg); opacity: 1; } 100% { transform: translate(calc(var(--vx) * 250px), calc(var(--vy) * 250px + 150px)) rotate(720deg); opacity: 0; } }
    </style>
</head>
<body>
    <audio id="backgroundMusic" loop></audio>

    <div id="game-container">
        <div id="game">
            <div id="score" role="status" aria-live="polite"><span id="player1Score">0</span> - <span id="player2Score">0</span></div>
            <div id="player1" class="player"></div>
            <div id="player2" class="player"></div>
            <div id="ball"></div>
        </div>

        <div id="controls" aria-label="Game Controls">
             <div id="modeSelection">
                 <input type="radio" name="gameMode" value="1p" id="mode1P" checked> <label for="mode1P">1 Player</label>
                 <input type="radio" name="gameMode" value="2p" id="mode2P"> <label for="mode2P">2 Players</label>
             </div>
             <hr style="margin: 8px 0; border-color: #555;">
             <div id="options">
                 <div> <label for="difficultySelect">AI Difficulty:</label> <select id="difficultySelect"> <option value="easy">Easy</option> <option value="normal" selected>Normal</option> <option value="hard">Hard</option> <option value="veryHard">Very Hard</option> <option value="impossible">Impossible</option> </select> </div>
                 <div> <label for="winScoreInput">Win Score:</label> <input type="number" id="winScoreInput" value="10" min="1" max="1000" step="1"> </div>
                 <div> <label for="pointsPerScoreInput">Points/Score:</label> <input type="number" id="pointsPerScoreInput" value="1" min="1" max="1000" step="1"> </div>
                 <div> <label> <input type="checkbox" id="possessionToggle" checked> Serve on Score </label> </div>
                 <div> <label for="player1ColorPicker">P1 Color:</label> <input type="color" id="player1ColorPicker" value="#61dafb"> </div>
                 <div> <label for="player2ColorPicker">P2/AI Color:</label> <input type="color" id="player2ColorPicker" value="#f0db4f"> </div>
                 <div> <label for="ballColorPicker">Ball Color:</label> <input type="color" id="ballColorPicker" value="#ff5733"> </div>
                 <div> <label for="backgroundColorPicker">BG Color:</label> <input type="color" id="backgroundColorPicker" value="#1e1e1e"> </div>
                 <div>
                    <label for="musicSelect">Music:</label>
                    <select id="musicSelect">
                        </select>
                 </div>
             </div>
             <hr style="margin: 8px 0; border-color: #555;">
            <button id="startButton">Start Game</button>
            <button id="resetButton">Stop & Reset</button>
            <button id="undoButton" disabled>Undo Point</button>
            <button id="toggleMusicButton">Play Music</button> <button id="fullscreenButton">Fullscreen</button> <div id="instructions"> </div>
        </div>
    </div>

    <script>
        document.addEventListener("DOMContentLoaded", () => {

            // --- Elements & Constants ---
            const game = document.getElementById("game");
            const player1El = document.getElementById("player1");
            const player2El = document.getElementById("player2");
            const ballEl = document.getElementById("ball");
            const controlsEl = document.getElementById("controls");
            const startButton = document.getElementById("startButton");
            const resetButton = document.getElementById("resetButton");
            const undoButton = document.getElementById("undoButton");
            const difficultySelect = document.getElementById("difficultySelect");
            const possessionToggle = document.getElementById("possessionToggle");
            const toggleMusicButton = document.getElementById("toggleMusicButton"); // Correct ID
            const fullscreenButton = document.getElementById("fullscreenButton"); // NEW FS Button Ref
            const musicSelect = document.getElementById("musicSelect");       // NEW Music Select Ref
            const backgroundMusic = document.getElementById("backgroundMusic"); // NEW Audio Element Ref
            const instructionsEl = document.getElementById("instructions");
            const modeSelectionRadios = document.querySelectorAll('input[name="gameMode"]');
            const winScoreInput = document.getElementById('winScoreInput');
            const pointsPerScoreInput = document.getElementById('pointsPerScoreInput');
            const gameContainer = document.getElementById('game-container');
            const player1ScoreEl = document.getElementById("player1Score");
            const player2ScoreEl = document.getElementById("player2Score");
            const player1ColorPicker = document.getElementById('player1ColorPicker');
            const player2ColorPicker = document.getElementById('player2ColorPicker');
            const ballColorPicker = document.getElementById('ballColorPicker');
            const backgroundColorPicker = document.getElementById('backgroundColorPicker');

            // --- Music Track Data (Replace srcs with your actual file paths!) ---
            const musicTracks = [
                { name: "None", src: "" },
                { name: "Chill Vibes", src: "music/placeholder_chill.mp3" },
                { name: "Retro Synth", src: "music/placeholder_synth.mp3" },
                { name: "Action Pulse", src: "music/placeholder_action.ogg" },
                { name: "Focused Flow", src: "music/placeholder_focus.mp3" },
                { name: "Pixel Pursuit", src: "music/placeholder_8bit.wav" },
                { name: "Cosmic Drift", src: "music/placeholder_ambient.mp3" },
                { name: "Intense Battle", src: "music/placeholder_battle.mp3" },
                { name: "Smooth Groove", src: "music/placeholder_groove.ogg" },
                { name: "Tension Rising", src: "music/placeholder_tension.mp3" },
                { name: "Victory Fanfare", src: "music/placeholder_win.mp3" }, // Example short track
            ];

            // --- Game Constants --- (Same)
            const PADDLE_HEIGHT = 100; const PADDLE_WIDTH = 15; const BALL_SIZE = 15;
            const PLAYER_SPEED = 6; const MAX_BOUNCE_ANGLE = Math.PI / 4;
            const INITIAL_BALL_SPEED = 5; const BALL_SPEED_INCREASE = 0.2;
            const WIN_PARTICLE_COUNT = 40;

             // --- Game State --- (Same)
             let player1, player2, ball, ai;
             let score = [0, 0]; let lastUpdate = 0; let gameRunning = false;
             let ballPossessionOnScore = true; let keysPressed = {};
             let currentBallSpeed = INITIAL_BALL_SPEED; let gameMode = '1p';
             let winScoreLimit = 10; let pointsPerScoreValue = 1;
             let animationFrameId = null; let framesSinceStart = 0;
             let lastScoreState = null;

             // --- Basic Element Check ---
             // Added checks for new audio/music elements
              if (!game || !player1El || !player2El || !ballEl || !controlsEl || !startButton || !resetButton || !undoButton || !toggleMusicButton || !fullscreenButton || !musicSelect || !backgroundMusic /* ... other elements ... */) {
                 console.error("FATAL: Core game, control, or music elements not found! Check HTML IDs.");
                 alert("Error initializing game elements. Check console (F12).");
                 return;
              }

             // --- Classes (Player, Ball, AI - Unchanged structurally) ---
              class Player { /* ... Player class code ... */ constructor(id, side) { this.el = document.getElementById(id); if (!this.el) { throw new Error(`Player element not found: ${id}`); } this.side = side; this.height = PADDLE_HEIGHT; this.width = PADDLE_WIDTH; this.speed = PLAYER_SPEED; this.y = (game.clientHeight - this.height) / 2; } update(deltaTime) { let dy = 0; if (!gameRunning) return; if (gameMode === '1p') { if (this.side === 'left') { if (keysPressed['arrowup'] || keysPressed['w']) { dy = -this.speed; } if (keysPressed['arrowdown'] || keysPressed['s']) { dy = this.speed; } } } else { if (this.side === 'left') { if (keysPressed['arrowup']) { dy = -this.speed; } if (keysPressed['arrowdown']) { dy = this.speed; } } else if (this.side === 'right') { if (keysPressed['w']) { dy = -this.speed; } if (keysPressed['s']) { dy = this.speed; } } } if (dy !== 0) { this.move(dy); } if (keysPressed[' '] && ball.owner === this) { this.fire(); } } move(dy) { const newY = this.y + dy; const maxY = game.clientHeight - this.height; this.y = Math.max(0, Math.min(newY, maxY)); this.el.style.top = `${this.y}px`; } fire() { if (ball.owner === this) { let angle = (Math.random() - 0.5) * Math.PI / 6; if (gameMode === '1p' && this.side === "right" && player1) { const playerCenterY = player1.y + player1.height / 2; const paddleCenterY = this.y + this.height / 2; const targetY = game.clientHeight / 2 + (playerCenterY - paddleCenterY) * 0.2; const deltaY = targetY - (this.y + this.height / 2); const targetAngle = Math.atan2(deltaY, game.clientWidth * 0.8); angle = Math.max(-MAX_BOUNCE_ANGLE * 0.8, Math.min(targetAngle, MAX_BOUNCE_ANGLE * 0.8)); } const directionX = this.side === "left" ? 1 : -1; ball.velocity = [ directionX * currentBallSpeed * Math.cos(angle), currentBallSpeed * Math.sin(angle) ]; ball.owner = null; } } getCenterY() { return this.y + this.height / 2; } }
              class Ball { /* ... Ball class code ... */ constructor() { this.el = ballEl; if(!this.el) { throw new Error("Ball element not found"); } this.size = BALL_SIZE; this.reset(null); } reset(ownerInstance = null) { this.owner = ownerInstance; currentBallSpeed = INITIAL_BALL_SPEED; if (this.owner) { this.followOwner(); this.velocity = [0, 0]; } else { this.x = (game.clientWidth - this.size) / 2; this.y = (game.clientHeight - this.size) / 2; const angle = (Math.random() * Math.PI / 2) - Math.PI / 4; const directionX = Math.random() < 0.5 ? 1 : -1; this.velocity = [ directionX * currentBallSpeed * Math.cos(angle), currentBallSpeed * Math.sin(angle) ]; this.owner = null; } this.updateVisual(); } update(deltaTime) { if (!gameRunning && !this.owner) return; if (this.owner) { this.followOwner(); } else { this.x += this.velocity[0]; this.y += this.velocity[1]; if (this.y <= 0) { this.y = 0; this.velocity[1] *= -1; } else if (this.y >= game.clientHeight - this.size) { this.y = game.clientHeight - this.size; this.velocity[1] *= -1; } } this.updateVisual(); } followOwner() { if (!this.owner) return; const ownerY = this.owner.y; const ownerCenterY = ownerY + this.owner.height / 2; this.y = ownerCenterY - this.size / 2; if (this.owner.side === "left") { this.x = this.owner.width + 10 + 5; } else { this.x = game.clientWidth - this.owner.width - 10 - this.size - 5; } } updateVisual() { if (this.el) { this.el.style.left = `${this.x}px`; this.el.style.top = `${this.y}px`; } } }
              class AI { /* ... AI class code (speed change applied in setDifficulty) ... */ constructor(playerToControl) { this.ctl = playerToControl; this.difficultyFactor = 0.7; this.reactionTimer = 0; this.reactionDelay = 150; this.fireDelay = 500; this.fireTimer = 0; this.predictiveError = 0.1; this.maxSpeedMultiplier = 1.0; } setDifficulty(level) { /* console.log(`AI Difficulty set to: ${level}`); */ switch(level) { case 'easy': this.difficultyFactor = 0.4; this.reactionDelay = 300; this.fireDelay = 800; this.predictiveError = 0.3; this.maxSpeedMultiplier = 1.0; break; case 'normal': this.difficultyFactor = 0.7; this.reactionDelay = 180; this.fireDelay = 600; this.predictiveError = 0.15; this.maxSpeedMultiplier = 1.0; break; case 'hard': this.difficultyFactor = 1.0; this.reactionDelay = 100; this.fireDelay = 400; this.predictiveError = 0.08; this.maxSpeedMultiplier = 1.2; break; case 'veryHard': this.difficultyFactor = 1.3; this.reactionDelay = 50; this.fireDelay = 250; this.predictiveError = 0.04; this.maxSpeedMultiplier = 1.4; break; case 'impossible': this.difficultyFactor = 1.8; this.reactionDelay = 0; this.fireDelay = 150; this.predictiveError = 0.01; this.maxSpeedMultiplier = 1.5; break; } /* console.log(` -> Speed Multiplier: ${this.maxSpeedMultiplier}`); */ } update(deltaTime) { /* ... AI update logic ... */ if (!gameRunning) return; if (ball.owner === this.ctl) { this.fireTimer += deltaTime; if (this.fireTimer >= this.fireDelay) { this.ctl.fire(); this.fireTimer = 0; } return; } else { this.fireTimer = 0; } this.reactionTimer += deltaTime; if (this.reactionTimer >= this.reactionDelay && ball.velocity[0] > 0) { this.reactionTimer = 0; const distanceToPaddle = game.clientWidth - this.ctl.width - 10 - ball.x; const ballSpeedX = Math.max(Math.abs(ball.velocity[0]), 1); const timeToReach = distanceToPaddle / ballSpeedX; let predictedBallY = ball.y + ball.velocity[1] * timeToReach; const errorAmount = (Math.random() - 0.5) * 2 * this.predictiveError * game.clientHeight; predictedBallY += errorAmount; if (predictedBallY < 0 || predictedBallY > game.clientHeight - ball.size) { if (predictedBallY < 0) { predictedBallY = Math.abs(predictedBallY); } else { predictedBallY = (game.clientHeight - ball.size) - (predictedBallY - (game.clientHeight - ball.size)); } } const targetY = Math.max(ball.size / 2, Math.min(predictedBallY, game.clientHeight - ball.size / 2)); const paddleCenter = this.ctl.getCenterY(); const targetPaddleCenter = targetY; let dy = 0; const deadZone = this.ctl.height * 0.1 * (1 / this.difficultyFactor) ; if (paddleCenter < targetPaddleCenter - deadZone) { dy = this.ctl.speed * this.maxSpeedMultiplier; } else if (paddleCenter > targetPaddleCenter + deadZone) { dy = -this.ctl.speed * this.maxSpeedMultiplier; } if (dy !== 0) { this.ctl.move(dy); } } } }

            // --- Event Listeners ---
             setupEventListeners();

            // --- Game Functions ---

             function setupEventListeners() {
                 document.addEventListener('keydown', (e) => { if(gameRunning) keysPressed[e.key.toLowerCase()] = true; });
                 document.addEventListener('keyup', (e) => { if(gameRunning) keysPressed[e.key.toLowerCase()] = false; });
                 startButton.addEventListener("click", startGame);
                 resetButton.addEventListener("click", handleResetGame);
                 undoButton.addEventListener("click", handleUndoPoint);
                 toggleMusicButton.addEventListener("click", handleToggleMusic); // Updated handler name
                 fullscreenButton.addEventListener("click", toggleFullscreen);   // NEW Fullscreen handler
                 musicSelect.addEventListener("change", handleMusicSelection); // NEW Music select handler
                 difficultySelect.addEventListener("change", changeDifficulty);
                 possessionToggle.addEventListener("change", (e) => { ballPossessionOnScore = e.target.checked; });
                 modeSelectionRadios.forEach(radio => { radio.addEventListener('change', handleModeChange); });
                 winScoreInput.addEventListener('change', handleWinScoreChange);
                 pointsPerScoreInput.addEventListener('change', handlePointsChange);
                 player1ColorPicker.addEventListener('input', (e) => { player1El.style.backgroundColor = e.target.value; });
                 player2ColorPicker.addEventListener('input', (e) => { player2El.style.backgroundColor = e.target.value; });
                 ballColorPicker.addEventListener('input', (e) => { ballEl.style.backgroundColor = e.target.value; });
                 backgroundColorPicker.addEventListener('input', (e) => { game.style.backgroundColor = e.target.value; });

                 // NEW: Listener for fullscreen changes (e.g., user pressing ESC)
                 document.addEventListener('fullscreenchange', updateFullscreenButton);
             }

             function initializeGame() {
                 console.log("Initializing game...");
                 try {
                     if (animationFrameId) { cancelAnimationFrame(animationFrameId); animationFrameId = null; }
                     gameRunning = false;

                     populateMusicSelect(); // Populate dropdown first
                     handleMusicSelection(); // Set initial music state based on default selection

                     score = [0, 0]; lastScoreState = null; keysPressed = {}; framesSinceStart = 0;

                     if (!player1) player1 = new Player("player1", "left");
                     if (!player2) player2 = new Player("player2", "right");
                     if (!ball) ball = new Ball(); else ball.reset(null);
                     if (!ai) ai = new AI(player2);

                     handleWinScoreChange({ target: winScoreInput });
                     handlePointsChange({ target: pointsPerScoreInput });
                     ballPossessionOnScore = possessionToggle.checked;
                     gameMode = document.querySelector('input[name="gameMode"]:checked').value;

                     player1El.style.backgroundColor = player1ColorPicker.value;
                     player2El.style.backgroundColor = player2ColorPicker.value;
                     ballEl.style.backgroundColor = ballColorPicker.value;
                     game.style.backgroundColor = backgroundColorPicker.value;

                     handleModeChange();
                     resetPaddles();
                     ball.updateVisual();
                     updateScoreDisplay();
                     updateInstructions();
                     undoButton.disabled = true;
                     updateFullscreenButton(); // Set initial fullscreen button text

                     backgroundMusic.pause(); // Ensure music is paused on init
                     updateMusicToggleButton(); // Set initial music button text


                     console.log("Initialization complete. Ready to start.");
                 } catch (error) { /* ... error handling ... */ console.error("Error during game initialization:", error); alert(`A critical error occurred during initialization: ${error.message}. Check the console (F12).`); /* disable buttons */ }
             }

             // NEW: Populate Music Select Dropdown
             function populateMusicSelect() {
                musicSelect.innerHTML = ''; // Clear existing options
                musicTracks.forEach(track => {
                    const option = document.createElement('option');
                    option.value = track.src;
                    option.textContent = track.name;
                    musicSelect.appendChild(option);
                });
             }

             // NEW: Handle Music Selection Change
             function handleMusicSelection() {
                const selectedSrc = musicSelect.value;
                if (selectedSrc && backgroundMusic.src !== selectedSrc) { // Check if src actually changed
                    backgroundMusic.src = selectedSrc;
                    console.log(`Music source set to: ${selectedSrc}`);
                    // Don't auto-play here, wait for user action (Start Game or Toggle Button)
                    // If music was playing, changing track might stop it depending on browser,
                    // so pause explicitly unless we intend to autoplay the new track.
                     if (!backgroundMusic.paused) {
                        backgroundMusic.pause(); // Pause if changing track while playing
                        // Optionally attempt to play new track immediately: playMusic();
                     }
                } else if (!selectedSrc) {
                    // "None" selected
                    backgroundMusic.pause();
                    backgroundMusic.src = ""; // Clear src
                    console.log("Music set to None.");
                }
                updateMusicToggleButton(); // Update button text based on new state
             }

             // NEW: Handle Toggle Music Button
             function handleToggleMusic() {
                if (backgroundMusic.paused) {
                    playMusic();
                } else {
                    pauseMusic();
                }
             }

             // NEW: Play Music Function (with error handling)
             function playMusic() {
                const selectedSrc = musicSelect.value;
                if (!selectedSrc) {
                    console.log("Play clicked, but no music selected.");
                    return;
                }
                // Ensure src is set if it wasn't (e.g., after selecting None then a track)
                if (!backgroundMusic.src || backgroundMusic.src !== selectedSrc) {
                   backgroundMusic.src = selectedSrc;
                }

                console.log("Attempting to play music...");
                const playPromise = backgroundMusic.play();

                if (playPromise !== undefined) {
                    playPromise.then(_ => {
                        // Autoplay started!
                        console.log("Music playback started.");
                        updateMusicToggleButton();
                    })
                    .catch(error => {
                        // Autoplay was prevented.
                        console.warn("Music playback failed:", error);
                        // Optionally inform the user they might need to click again or start the game.
                        updateMusicToggleButton(); // Reflect that it's paused
                    });
                } else {
                     // Older browsers might not return a promise. Assume it might work.
                     updateMusicToggleButton();
                }
             }

             // NEW: Pause Music Function
             function pauseMusic() {
                 backgroundMusic.pause();
                 console.log("Music paused.");
                 updateMusicToggleButton();
             }

             // NEW: Update Toggle Music Button Text
             function updateMusicToggleButton() {
                if (backgroundMusic.paused) {
                    toggleMusicButton.textContent = "Play Music";
                } else {
                    toggleMusicButton.textContent = "Pause Music";
                }
             }


             // NEW: Toggle Fullscreen Function
             function toggleFullscreen() {
                if (!document.fullscreenElement) {
                    // Enter fullscreen
                    document.documentElement.requestFullscreen()
                        .catch(err => {
                            console.error(`Error attempting to enable full-screen mode: ${err.message} (${err.name})`);
                            alert(`Could not enter fullscreen mode: ${err.message}`);
                        });
                } else {
                    // Exit fullscreen
                    if (document.exitFullscreen) {
                        document.exitFullscreen();
                    }
                }
                // Button text updated by 'fullscreenchange' event listener
             }

             // NEW: Update Fullscreen Button Text based on state
             function updateFullscreenButton() {
                 if (document.fullscreenElement) {
                     fullscreenButton.textContent = "Exit Fullscreen";
                 } else {
                     fullscreenButton.textContent = "Fullscreen";
                 }
             }


             function handleWinScoreChange(e) { /* ... same ... */ let newValue = parseInt(e.target.value, 10); const minVal = parseInt(winScoreInput.min, 10) || 1; const maxVal = parseInt(winScoreInput.max, 10) || 1000; if (isNaN(newValue)) { newValue = 10; } winScoreLimit = Math.max(minVal, Math.min(newValue, maxVal)); e.target.value = winScoreLimit; console.log("Win score limit set to:", winScoreLimit); updateInstructions(); }
             function handlePointsChange(e) { /* ... same ... */ let newValue = parseInt(e.target.value, 10); if (isNaN(newValue) || newValue < 1) { newValue = 1; } const maxVal = parseInt(pointsPerScoreInput.max, 10) || 1000; pointsPerScoreValue = Math.min(newValue, maxVal); e.target.value = pointsPerScoreValue; console.log("Points per score set to:", pointsPerScoreValue); updateInstructions(); }
             function handleModeChange() { /* ... same ... */ const selectedMode = document.querySelector('input[name="gameMode"]:checked').value; gameMode = selectedMode; const is1P = (gameMode === '1p'); difficultySelect.disabled = !is1P; difficultySelect.style.opacity = is1P ? '1' : '0.5'; difficultySelect.style.cursor = is1P ? 'pointer' : 'not-allowed'; if (is1P && ai) { changeDifficulty({ target: difficultySelect }); } resetPaddles(); if (ball) ball.reset(null); updateInstructions(); }
             function updateInstructions() { /* ... same ... */ let text = `Win: ${winScoreLimit} | Pts: ${pointsPerScoreValue} | `; if (gameMode === '1p') { const difficultyText = difficultySelect.options[difficultySelect.selectedIndex].text; text += `P1 [↑][↓] | Fire [Space] | AI: ${difficultyText}`; } else { text += `P1 [↑][↓] | P2 [W][S] | Fire [Space]`; } instructionsEl.innerHTML = text.replace(/\|/g, '<span style="opacity:0.5; margin: 0 4px;">|</span>'); }


             function startGame() { // Modified to play music on start
                 if (gameRunning) { return; }
                 console.log(`Starting game... Mode: ${gameMode}, Difficulty: ${gameMode === '1p' ? difficultySelect.value : 'N/A'}`);
                 try {
                     if (!player1 || !player2 || !ball) { throw new Error("Initialization failed, cannot start game."); }
                     score = [0, 0]; keysPressed = {}; framesSinceStart = 0; lastScoreState = null; undoButton.disabled = true;
                     updateScoreDisplay(); resetPaddles();
                     player1El.style.backgroundColor = player1ColorPicker.value; player2El.style.backgroundColor = player2ColorPicker.value; ballEl.style.backgroundColor = ballColorPicker.value; game.style.backgroundColor = backgroundColorPicker.value;
                     if (gameMode === '1p') { changeDifficulty({ target: difficultySelect }); }
                     ball.reset(null);
                     gameRunning = true;

                     // Attempt to play selected music on game start
                     playMusic(); // Uses the function which handles 'None' selection etc.

                     lastUpdate = performance.now();
                     if (animationFrameId) cancelAnimationFrame(animationFrameId);
                     animationFrameId = requestAnimationFrame(update);
                     console.log("Game loop started.");
                 } catch (error) { /* ... error handling ... */ console.error("Error starting game:", error); alert(`Failed to start game: ${error.message}`); gameRunning = false; }
             }

             function pauseGameLoop(winnerMessage = "") { // Modified to pause music on win/stop
                 if (!gameRunning && !winnerMessage) return;
                 console.log("Pausing game loop.");
                 const wasRunning = gameRunning; // Check if it was running before setting false
                 gameRunning = false;
                 if (animationFrameId) { cancelAnimationFrame(animationFrameId); animationFrameId = null; }
                 keysPressed = {};

                 // Pause music only if game was actually running or ending
                 if (wasRunning) {
                    pauseMusic();
                 }

                 if (winnerMessage) {
                    lastScoreState = null; undoButton.disabled = true;
                    if (ball) ball.reset(null);
                    updateInstructions();
                    setTimeout(() => { alert(winnerMessage); }, 50);
                 }
             }

             function handleResetGame() { // Modified to pause music
                console.log("Stop & Reset button clicked.");
                pauseGameLoop(); // Stop the current game loop & pause music if running
                initializeGame(); // Re-initialize everything (sets music state based on selection)
             }

             function handleUndoPoint() { /* ... same ... */ if (!lastScoreState) { console.log("Undo clicked, but no previous score state found."); return; } console.log("Undoing last point..."); score = [...lastScoreState.score]; updateScoreDisplay(); let server = null; if (ballPossessionOnScore) { server = (lastScoreState.scorer === 1) ? player2 : player1; } ball.reset(server); console.log(`Score reverted to ${score[0]}-${score[1]}. Ball reset.`); lastScoreState = null; undoButton.disabled = true; }
             function resetPaddles() { /* ... same ... */ try { if (player1) { player1.y = (game.clientHeight - player1.height) / 2; player1.el.style.top = `${player1.y}px`; } if (player2) { player2.y = (game.clientHeight - player2.height) / 2; player2.el.style.top = `${player2.y}px`; } } catch(e) { console.error("Error resetting paddles", e); } }
             function changeDifficulty(event) { /* ... same ... */ const difficulty = event.target.value; if (ai && gameMode === '1p') { ai.setDifficulty(difficulty); updateInstructions(); } }
             function updateScoreDisplay() { /* ... same ... */ player1ScoreEl.textContent = score[0]; player2ScoreEl.textContent = score[1]; }
             function checkCollisions() { /* ... same ... */ if (!gameRunning || ball.owner) return; if (ball.velocity[0] < 0 && ball.x <= player1.el.offsetLeft + player1.width + ball.size / 2 && ball.x >= player1.el.offsetLeft && ball.y + ball.size > player1.y && ball.y < player1.y + player1.height) { const intersectY = player1.getCenterY() - (ball.y + ball.size / 2); const normalizedIntersectY = intersectY / (player1.height / 2); const bounceAngle = normalizedIntersectY * MAX_BOUNCE_ANGLE; currentBallSpeed += BALL_SPEED_INCREASE; ball.velocity[0] = currentBallSpeed * Math.cos(bounceAngle); ball.velocity[1] = -currentBallSpeed * Math.sin(bounceAngle); ball.x = player1.el.offsetLeft + player1.width + 1; } else if (ball.velocity[0] > 0 && ball.x + ball.size >= player2.el.offsetLeft - ball.size / 2 && ball.x <= player2.el.offsetLeft + player2.width && ball.y + ball.size > player2.y && ball.y < player2.y + player2.height) { const intersectY = player2.getCenterY() - (ball.y + ball.size / 2); const normalizedIntersectY = intersectY / (player2.height / 2); const bounceAngle = normalizedIntersectY * MAX_BOUNCE_ANGLE; currentBallSpeed += BALL_SPEED_INCREASE; ball.velocity[0] = -currentBallSpeed * Math.cos(bounceAngle); ball.velocity[1] = -currentBallSpeed * Math.sin(bounceAngle); ball.x = player2.el.offsetLeft - ball.size - 1; } }
             function checkScored() { /* ... same ... */ if (!gameRunning || ball.owner || framesSinceStart < 5) return; const gameWidth = game.clientWidth; let scorer = 0; if (ball.x <= 0) { scorer = 2; } else if (ball.x + ball.size >= gameWidth) { scorer = 1; } if (scorer !== 0) { lastScoreState = { score: [...score], scorer: scorer }; undoButton.disabled = false; if (scorer === 1) { score[0] += pointsPerScoreValue; } else { score[1] += pointsPerScoreValue; } updateScoreDisplay(); if (score[0] >= winScoreLimit || score[1] >= winScoreLimit) { const winnerName = score[0] >= winScoreLimit ? 'Player 1' : (gameMode === '1p' ? 'AI' : 'Player 2'); const finalScoreMsg = `Final Score: ${score[0]} - ${score[1]}`; console.log(`${winnerName} wins! ${finalScoreMsg}`); triggerWinAnimation(scorer === 1 ? 'left' : 'right'); pauseGameLoop(`${winnerName} wins! ${finalScoreMsg}`); } else { const server = ballPossessionOnScore ? (scorer === 1 ? player1 : player2) : null; ball.reset(server); } } }
             function triggerWinAnimation(winnerSide) { /* ... same ... */ const colors = ['var(--win-color1)', 'var(--win-color2)', 'var(--win-color3)', 'var(--win-color4)']; const emitterX = game.clientWidth / 2; const emitterY = game.clientHeight / 2; for (let i = 0; i < WIN_PARTICLE_COUNT; i++) { const particle = document.createElement('div'); particle.classList.add('win-particle'); game.appendChild(particle); const angle = Math.random() * Math.PI * 2; const speed = 0.8 + Math.random() * 0.7; const duration = 1.5 + Math.random() * 1.0; particle.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)]; particle.style.left = `${emitterX}px`; particle.style.top = `${emitterY}px`; particle.style.setProperty('--vx', Math.cos(angle) * speed); particle.style.setProperty('--vy', Math.sin(angle) * speed); particle.style.animation = `win-explode ${duration}s ease-out forwards`; setTimeout(() => { particle.remove(); }, duration * 1000); } }


             // --- Game Loop --- (Unchanged)
             function update(time) { if (!gameRunning) { animationFrameId = null; return; } const deltaTime = time - lastUpdate; const cappedDeltaTime = Math.min(deltaTime, 50); lastUpdate = time; framesSinceStart++; try { player1.update(cappedDeltaTime); if (gameMode === '1p') { ai.update(cappedDeltaTime); } else { player2.update(cappedDeltaTime); } ball.update(cappedDeltaTime); checkCollisions(); checkScored(); if (gameRunning) { animationFrameId = requestAnimationFrame(update); } else { console.log("Game loop ending because gameRunning became false."); animationFrameId = null; } } catch (error) { console.error("Error during game update:", error); alert(`A critical error occurred during the game loop: ${error.message}. Check the console (F12). Game stopped.`); pauseGameLoop(); } }

            // --- Start Initialization ---
             initializeGame();

        }); // End DOMContentLoaded
    </script>
</body>
</html>
